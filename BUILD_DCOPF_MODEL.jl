# Function to build the DC OPF model
function Make_DCOPF_Model!(model::Model, 
    B::SparseMatrixCSC,
    DBUS::DataFrame, 
    DGEN::DataFrame, 
    DCIR::DataFrame, 
    bus_gen_circ_dict::OrderedDict,
    base_MVA::Float64, 
    nBUS::Int64, 
    nGEN::Int64, 
    nCIR::Int64)

    """
    This function builds a general AC OPF Model with the objective function, variables and constraints
    """
    #---------------------------------------------
    # Get some variables associated with the buses
    #---------------------------------------------
    P_d  = deepcopy(DBUS.p_d) ./ base_MVA  # Active power demanded by the loads     [p.u.]
    g_sh = deepcopy(DBUS.g_sh) ./ base_MVA # Shunt conductance connected to the bus [p.u.]

    #------------------------------------------
    # Check if there is at least one swing bus
    #------------------------------------------
    SW = findall(x -> x == 3, DBUS.type)
    if isempty(SW) 
        throw(ArgumentError("You must define one bus as the SLACK BUS (type 3).")) 
    elseif length(SW) > 1 
        throw(ArgumentError("This code still does not support more than one SLACK BUS (type 3).")) 
    end

    # Define the voltage at each bus equal to 1 p.u.
    V = OrderedDict(bus => 1.0 for bus in eachindex(DBUS.bus))
    # V = OrderedDict{Int, Float64}()
    # for bus in eachindex(DBUS.bus)
    #     V[bus] = 1.0                   # Constant -> Voltage magnitude at the buses [p.u.]
    # end

    # Get the power transfer limits of each branch
    lower_bounds_branch, upper_bounds_branch = Get_Limits_Power_Transfer(DCIR, nCIR, base_MVA)

    # ========================================================================
    #              DEFINE THE VARIABLES OF THE MODEL
    # ========================================================================

    #-------------------------------------------------------------------------
    #                  Phase-angle of the voltage at the buses
    #-------------------------------------------------------------------------
    θ = OrderedDict{Int, JuMP.VariableRef}() # Dictionary to save the variables θ for each bus
    for bus in eachindex(DBUS.bus) # Loop in all buses
        θ[bus] = JuMP.@variable(model,
        lower_bound = -π, # Lower Bounds
        upper_bound = π,  # Upper Bounds
        base_name = "θ[$bus]"          # Decision variable -> Voltage angle at the buses [p.u.]
        )
    end

    #-------------------------------------------------------------------------
    #                  Active power generated by the generators
    #-------------------------------------------------------------------------
    P_g = OrderedDict{Int, JuMP.VariableRef}()
    for gen in 1:nGEN # Loop in all generators
        if DGEN.g_status[gen] == 1
            P_g[gen] = @variable(model,
                lower_bound = DGEN.pg_min[gen] / base_MVA, # Lower Bounds
                upper_bound = DGEN.pg_max[gen] / base_MVA, # Upper Bounds
                base_name = "P_g[$gen]"
            )
        end
    end
    
    # ========================================================================
    #            DEFINE THE OBJECTIVE FUNCTION OF THE MODEL
    # ========================================================================
    # Minimize total fuel cost
    model.ext[:objective] = OrderedDict{Symbol, Any}() # Dictionary to save the Objective Function
    total_cost = 0.0  # Initialize in zero

    for gen in 1:nGEN # Loop in all generators
        if DGEN.g_status[gen] == 1 && haskey(P_g, gen)
            if DGEN.g_cost_0[gen] != 0.0
                total_cost += DGEN.g_cost_0[gen]
            end
            if DGEN.g_cost_1[gen] != 0.0
                total_cost += DGEN.g_cost_1[gen] * P_g[gen] * base_MVA
            end
            if DGEN.g_cost_2[gen] != 0.0
                total_cost += DGEN.g_cost_2[gen] * (P_g[gen] * base_MVA)^2
            end
        end
    end

    model.ext[:objective] = @objective(model, Min, total_cost)
    
    # ========================================================================
    #            DEFINE THE CONSTRAINTS OF THE MODEL
    # ========================================================================

    # ******************************************
    # Equality Constraint -> angle of swing bus
    # ******************************************
    eq_const_angle_sw = OrderedDict{Int, JuMP.ConstraintRef}()

    if any(bus_gen_circ_dict[SW[1]][:gen_status] .== 1)                          # First check if the swing bus has at least one generator connected to it
        eq_const_angle_sw = JuMP.@constraint(model, θ[DBUS.bus[SW[1]]] == 0.0)   # Set the constraint -> Angle == 0
    else
        throw(ArgumentError("Swing bus $(SW[1]) must have at least one connected generator with status ON.")) # Throw an error if the swing bus has no generator connected to it
    end
   
    # ********************************************
    # Equality Constraints -> Active Power Balance
    # ********************************************

    p_flow_terms_dict = OrderedDict{Int, Vector{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}}}() # Dictionary of active power inflow/outflow
    # Generating expressions for the power flow in and out of the bus
    for bus in DBUS.bus # Loop in all buses
        terms_p = JuMP.GenericAffExpr{Float64, JuMP.VariableRef}[]  # List of expressions

        indices_circ_connected = bus_gen_circ_dict[bus][:circ]       # Circuits connected to bus "bus"
        if isempty(indices_circ_connected)
            throw(ArgumentError("The bus $bus is islanded, i.e., there is no line or transformer connected to it."))
        end

        # Generate the power flow terms between each adjacent bus
        for (id_bus, f_bus) in enumerate(DCIR.from_bus)
            t_bus = DCIR.to_bus[id_bus]
            if DCIR.l_status[id_bus] == 1
                if f_bus == bus
                    push!(terms_p, B[f_bus, t_bus] * (θ[f_bus] - θ[t_bus]))  # Power flows out of bus
                elseif t_bus == bus
                    push!(terms_p, B[t_bus, f_bus] * (θ[t_bus] - θ[f_bus]))  # Power flows into bus
                end
            end
        end
        p_flow_terms_dict[bus] = terms_p # Update the dictionary
    end

    eq_const_p_balance = OrderedDict{Int, JuMP.ConstraintRef}() # Dictionary used to save the equality constraints
    # Create the equality constraints
    for bus in 1:nBUS # Loop in all buses
        indices_bus_gen        = bus_gen_circ_dict[bus][:gen_ids] # Generators at bus "bus"
        indices_circ_connected = bus_gen_circ_dict[bus][:circ]    # Circuits connected to bus "bus
        terms_p                = p_flow_terms_dict[bus]           # Active power flow terms

        if isempty(indices_circ_connected) # Check if the bus has at least one branch connected to it
            throw(ArgumentError("The bus $bus is islanded, i.e., there is no line or transformer connected to it."))
        end

        # Get generator variables from the dictionary for those ON at this bus
        Pg_terms = [P_g[gen] for gen in indices_bus_gen if haskey(P_g, gen)]

        Pg_sum = isempty(Pg_terms) ? 0.0 : sum(Pg_terms) # Sum P_g terms; zero otherwise

        if g_sh[bus] == 0.0 # Check if the bus has shunt conductance connected to it 
            eq_const_p_balance[bus] = @constraint(model, Pg_sum - P_d[bus] - sum(terms_p) == 0.0)
        else
            eq_const_p_balance[bus] = @constraint(model, Pg_sum - P_d[bus] - g_sh[bus] - sum(terms_p) == 0.0)
        end
    end

    # ****************************************************************
    # Inequality Constraints -> Power Transfer Limits in the Branches
    # ****************************************************************
    ineq_const_p_ik_lb = OrderedDict{Int, JuMP.ConstraintRef}() # Dict to save inequality constraints of power transfer limits in the branches (lower bound)
    ineq_const_p_ik_ub = OrderedDict{Int, JuMP.ConstraintRef}() # Dict to save inequality constraints of power transfer limits in the branches (upper bound)

    # Loop in all branches
    for branch = 1:nCIR
        if DCIR.l_status[branch] == 1 # Check if the branch is ON

            f_bus = DCIR.from_bus[branch]  # Bus from
            t_bus = DCIR.to_bus[branch]    # Bus to
            b = 1 / (DCIR.l_reac[branch]) # Branch series susceptance                   

            # Limit of the power flow from f_bus to t_bus
            ineq_const_p_ik_lb[branch] = JuMP.@constraint(model, get(lower_bounds_branch, branch, -Inf) - (b * (θ[f_bus] - θ[t_bus])) <= 0.0)
            ineq_const_p_ik_ub[branch] = JuMP.@constraint(model, (b * (θ[f_bus] - θ[t_bus])) - get(upper_bounds_branch, branch, Inf) <= 0.0)
        end
    end

    # ************************************************************************
    # Inequality Constraint -> Voltage Angle Difference Between Adjacent Buses
    # ************************************************************************
    pair_circ_map, sorted_pair_info = Get_Limits_Angular_Differences(DCIR, nCIR)
    ineq_const_diff_ang_lb  = OrderedDict{Int, JuMP.ConstraintRef}() # Vector to save inequality constraints of angle difference between adjacent buses (lower bound)
    ineq_const_diff_ang_ub  = OrderedDict{Int, JuMP.ConstraintRef}() # Vector to save inequality constraints of angle difference between adjacent buses (upper bound)

    for (pair, pair_data) in sorted_pair_info
        f_bus, t_bus = pair           # Bus from and bus to
        circ_id = pair_circ_map[pair] # ID of the circuit

        min_ang = pair_data.min_ang # Minimum angular difference between adjacent buses
        max_ang = pair_data.max_ang # Maximum angular difference between adjacent buses

        
        if min_ang >= -30 && max_ang <= 30 
            ineq_const_diff_ang_lb[circ_id] = JuMP.@constraint(model, deg2rad(min_ang) - (θ[f_bus] - θ[t_bus]) <= 0.0)
            ineq_const_diff_ang_ub[circ_id] = JuMP.@constraint(model, (θ[f_bus] - θ[t_bus]) - deg2rad(max_ang) <= 0.0)

        elseif min_ang < -30 && max_ang <= 30
            println("Correcting angle constraints between adjacent buses ($f_bus, $t_bus): setting ang_min to -30°.")
            ineq_const_diff_ang_lb[circ_id] = JuMP.@constraint(model, deg2rad(-30) - (θ[f_bus] - θ[t_bus]) <= 0.0)
            ineq_const_diff_ang_ub[circ_id] = JuMP.@constraint(model, (θ[f_bus] - θ[t_bus]) - deg2rad(max_ang) <= 0.0)

        elseif min_ang >= -30 && max_ang > 30
            println("Correcting angle constraints between adjacent buses ($f_bus, $t_bus): setting ang_max to +30°.")
            ineq_const_diff_ang_lb[circ_id] = JuMP.@constraint(model, deg2rad(min_ang) - (θ[f_bus] - θ[t_bus]) <= 0.0)
            ineq_const_diff_ang_ub[circ_id] = JuMP.@constraint(model, (θ[f_bus] - θ[t_bus]) - deg2rad(30) <= 0.0)

        else # min_ang < -30 && max_ang > 30
            println("Correcting angle constraints between adjacent buses ($f_bus, $t_bus): setting ang_min to -30° and ang_max to +30°.")
            ineq_const_diff_ang_lb[circ_id] = JuMP.@constraint(model, deg2rad(-30) - (θ[f_bus] - θ[t_bus]) <= 0.0)
            ineq_const_diff_ang_ub[circ_id] = JuMP.@constraint(model, (θ[f_bus] - θ[t_bus]) - deg2rad(30) <= 0.0)
        end
    end

    # =============================================================
    # Return model, variables and constraints to the main function
    # =============================================================
    return model, V, θ, P_g, eq_const_angle_sw, eq_const_p_balance, ineq_const_p_ik_lb, ineq_const_p_ik_ub, ineq_const_diff_ang_lb, ineq_const_diff_ang_ub # Return the model to the main function
end

# *****************************************************************************
# Auxiliar function to get the limits of power transfer capacity in each branch
# *****************************************************************************
function Get_Limits_Power_Transfer(DCIR::DataFrame, nCIR::Int64, base_MVA::Float64)
    # Check if the branches have capacity/thermal limits defined in the input data
    all_cap           = [DCIR.l_cap_1 DCIR.l_cap_2 DCIR.l_cap_3] # Matrix containing all three capacity limits defined in the input data file
    lower_bounds_branch = OrderedDict{Int, Float64}()            # Dictionary to save lower bounds of capacity limits for branches if it is defined in the input data file
    upper_bounds_branch = OrderedDict{Int, Float64}()            # Dictionary to save upper bounds of capacity limits for branches if it is defined in the input data file

    # Loop to check if the branch has at least one capacity limit defined in the input data file
    # If not defined, the power flow through the branch has no bounds
    for branch in 1:nCIR
        if any(!iszero, all_cap[branch, :])  # Line ON or OFF and has capacity
            index_cap = findfirst(!iszero, all_cap[branch, :])
            cap = all_cap[branch, index_cap]
            lower_bounds_branch[branch] = -cap / base_MVA # Lower Bounds
            upper_bounds_branch[branch] =  cap / base_MVA # Upper Bounds
        end
    end
    return lower_bounds_branch, upper_bounds_branch
end

# ****************************************************************************************************************************************
# Auxiliar function to get the limits of angular differences between adjacent buses if parallel circuits are connected between these buses
# ****************************************************************************************************************************************
function Get_Limits_Angular_Differences(DCIR::DataFrame, nCIR::Int64)
    # Initialize dictionary with count, min_ang, max_ang
    pair_info = OrderedDict{Tuple{Int, Int}, NamedTuple{(:count, :min_ang, :max_ang), Tuple{Int, Float64, Float64}}}()
    pair_circ_map = OrderedDict{Tuple{Int, Int}, Int}()

    # This loop maps the circuits that have parallel branches, count the number of parallel lines/transformers,
    # and save the minimum and maximum angular difference for the buses related to these circuits
    for branch in 1:nCIR
        if DCIR.l_status[branch] == 1                                  # Only consider active branches
            f_bus, t_bus = DCIR.from_bus[branch], DCIR.to_bus[branch]  # Bus from and bus to
            pair = (min(f_bus, t_bus), max(f_bus, t_bus))              # Sort the buses id in ascending order
            branch_id = DCIR.circ[branch]                              # Get the number id of the branch
 
            if !haskey(pair_circ_map, pair)     # Check if these buses were already addded to the map
                pair_circ_map[pair] = branch_id  # Get only the number of the first branch ON connecting these buses
            else
                pair_circ_map[pair] = min(pair_circ_map[pair], branch_id) # Get the number of the first branch ON connecting these buses
            end
            
            if haskey(pair_info, pair) # Check if this pair of buses were already added
                # Update count
                old       = pair_info[pair]
                new_count = old.count + 1                            # Count the number of branches ON connecting these buses
                new_min   = min(old.min_ang, DCIR.ang_min[branch])   # Get the minimum angle defined for the branches connecting these buses
                new_max   = max(old.max_ang, DCIR.ang_max[branch])   # Get the maximum angle defined for the branches connecting these buses
                pair_info[pair] = (new_count, new_min, new_max)
            else
                pair_info[pair] = (1, DCIR.ang_min[branch], DCIR.ang_max[branch]) # Add this pair of buses for the first time
            end
        end
    end
    sorted_pair_info  = sort(collect(pair_info), by = x -> pair_circ_map[x[1]]) # Sort the data inside pair_info Dict

    return pair_circ_map, sorted_pair_info
end
